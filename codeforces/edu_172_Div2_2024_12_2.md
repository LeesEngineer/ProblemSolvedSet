# A. Greedy Monocarp

</br>

<p>有 𝑛
 个箱子；第 𝑖
 个箱子最初包含 𝑎𝑖
 个硬币。对于每个箱子，您可以选择任意非负数( 0
 或更大)的硬币数量添加到该箱子中，但有一个限制：所有箱子中的硬币总数必须至少为 𝑘
 。

在您向箱子中添加完硬币后，贪婪的 Monocarp 来了，他想要硬币。他会一个接一个地拿走箱子，而且由于他很贪婪，他总是会选择硬币数量最多的箱子。一旦他拿走的箱子中的硬币总数至少为 𝑘
 ，Monocarp 就会停止。

您希望 Monocarp 拿走尽可能少的硬币，因此您必须以这样的方式将硬币添加到箱子中，以便当 Monocarp 停止拿走箱子时，他将拥有 <b>恰好 𝑘
 </b> 个硬币。计算您必须添加的最少硬币数量。</p>

</br>

 <p><b>输入</b>

第一行包含一个整数 𝑡
 ( 1≤𝑡≤1000
 ) — 测试用例的数量。

每个测试用例包含两行：</p>

- 第一行包含两个整数 𝑛
 和 𝑘
 ( 1≤𝑛≤50
 ; 1≤𝑘≤107
 )；
- 第二行包含 𝑛
 个整数 𝑎1,𝑎2,…,𝑎𝑛
 ( 1≤𝑎𝑖≤𝑘
 )。

</br>

<b>输出</b>

<p>对于每个测试用例，打印一个整数 — 您必须添加的最小硬币数量，以便当 Monocarp 停止拿走箱子时，他有恰好 k 个硬币。可以证明，在问题的约束下，这总是可能的。</p>

```
//input
4
5 4
4 1 2 3 2
5 10
4 1 2 3 2
2 10
1 1
3 8
3 3 3
```

```
//output
0
1
8
2
```

</br>

<b>注意</b>

<p>
  在示例的第一个测试用例中，您不必添加任何硬币。当 Monocarp 到达时，他将拿走装有 4
 个硬币的箱子，因此他将拥有恰好 4
 个硬币。

在示例的第二个测试用例中，您可以将 1
 个硬币添加到第 4
 个箱子中，因此，当 Monocarp 到达时，他将拿走一个装有 4
 个硬币的箱子，然后拿走另一个装有 4
 个硬币的箱子，以及一个装有 2
 个硬币的箱子。

在示例的第三个测试用例中，您可以将 3
 个硬币添加到第 1
 个箱子中，并将 5
 个硬币添加到第 2
 个箱子中。

在示例的第四个测试用例中，你可以将 1
 枚硬币添加到第 1
 枚箱子中，将 1
 枚硬币添加到第 3
 枚箱子中。
 </p>

 </br>

```
#include <iostream>
#include <algorithm>
#include <functional>

using namespace std;

const int N = 60;

int f[N];

int main()
{
    int t;
    scanf("%d", &t);
    while(t --)
    {
        int n, k;
        scanf("%d%d", &n, &k);
        for(int i = 0; i < n; i++) scanf("%d", &f[i]);

        sort(f, f + n, greater<int>());

        for(int i = 0; i < n; i++) f[i] += f[i - 1];

        for(int i = 0; i < n; i ++)
        {
            if(f[i] == k)
            {
                printf("0\n");
                break;
            }

            if(f[i] > k)
            {
                int ans = k - f[i - 1];
                printf("%d\n", ans);
                break;
            }
        }
        if(k - f[n - 1] > 0)
        {
            int ans = k - f[n - 1];
            printf("%d\n", ans);
        }
    }
    return 0;
}
```
































